import createLayout from 'layout-bmfont-text'
import createIndices from 'quad-indices'
import buffer from 'three-buffer-vertex-data'

import merge from 'lodash.merge'

import { Sphere, Box3 } from 'three'

import maths from './maths'

export default class TextGeometry extends THREE.BufferGeometry {
  constructor(opt) {
    super()

    if (typeof opt === 'string') {
      opt = { text: opt }
    }

    // use these as default values for any subsequent
    // calls to update()
    this._opt = merge({}, opt)

    // also do an initial setup...
    if (opt) this.update(opt)

  }

  update(opt) {
    if (typeof opt === 'string') {
      opt = { text: opt }
    }

    // use constructor defaults
    opt = merge({}, this._opt, opt)

    if (!opt.font) {
      throw new TypeError('must specify a { font } in options')
    }

    this.layout = createLayout(opt)

    // get vec2 texcoords
    var flipY = opt.flipY !== false

    // the desired BMFont data
    var font = opt.font

    // determine texture size from font file
    var texWidth = font.common.scaleW
    var texHeight = font.common.scaleH

    // get visible glyphs
    var glyphs = this.layout.glyphs.filter(function (glyph) {
      var bitmap = glyph.data
      return bitmap.width * bitmap.height > 0
    })

    // provide visible glyphs for convenience
    this.visibleGlyphs = glyphs

    let indices = [];
    let vertices = [];
    let normals = [];
    let uvs = [];
    let uvsBasic = [];

    let widthSegments = (opt.segments && opt.segments.x) || 1
    let heightSegments = (opt.segments && opt.segments.y) || 1

    let offset = 0

    glyphs.map((glyph, glyphIndex) => {
      var bitmap = glyph.data

      // bottom left position
      var x = glyph.position[0] + bitmap.xoffset
      var y = glyph.position[1] + bitmap.yoffset

      // quad size
      var w = bitmap.width
      var h = bitmap.height

      var bw = (bitmap.x + bitmap.width)
      var bh = (bitmap.y + bitmap.height)

      // top left position
      var u0 = bitmap.x / texWidth
      var v1 = bitmap.y / texHeight
      var u1 = bw / texWidth
      var v0 = bh / texHeight

      if (flipY) {
        v1 = (texHeight - bitmap.y) / texHeight
        v0 = (texHeight - bh) / texHeight
      }

      var width_half = w / 2;
      var height_half = h / 2;

      var gridX = Math.floor(widthSegments) || 1;
      var gridY = Math.floor(heightSegments) || 1;

      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;

      var segment_width = w / gridX;
      var segment_height = h / gridY;

      var ix, iy;

      // indices

      let offsetX = glyphIndex * 4 * widthSegments * heightSegments;
      offsetX = offset
      let offsetY = glyphIndex * 4 * heightSegments;

      for (iy = 0; iy < gridY; iy++) {

        for (ix = 0; ix < gridX; ix++) {

          var a = ix + gridX1 * iy + offsetX;
          var b = ix + gridX1 * (iy + 1) + offsetX;
          var c = (ix + 1) + gridX1 * (iy + 1) + offsetX;
          var d = (ix + 1) + gridX1 * iy + offsetX;

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);

        }

      }

      for (iy = 0; iy < gridY1; iy++) {

        var newY = iy * segment_height - height_half;

        for (ix = 0; ix < gridX1; ix++) {

          var newX = ix * segment_width - width_half;

          const vx = x + (w * (ix / gridX))
          const vy = y + (h * ((iy / gridY)))

          vertices.push(
            vx,
            -vy,
            0
          );

          offset++

          normals.push(0, 0, 1);

          uvs.push(u0 + ((u1 - u0) * (ix / gridX)));
          uvs.push(v0 + ((v1 - v0) * (1 - (iy / gridY))));

          uvsBasic.push(
            Math.abs(vx / this.layout.width)
          )
          uvsBasic.push(
            Math.abs((vy - this.layout.ascender) / (this.layout.height + this.layout.ascender))
          )
        }

      }

    })

    buffer.index(this, indices, 1);
    buffer.attr(this, 'position', vertices, 3);
    buffer.attr(this, 'normal', normals, 3);
    buffer.attr(this, 'uv', uvs, 2);
    buffer.attr(this, 'uvBasic', uvsBasic, 2);

    // update multipage data
    if (!opt.multipage && 'page' in this.attributes) {
      // disable multipage rendering
      this.removeAttribute('page')
    } else if (opt.multipage) {
      var pages = vertices.pages(glyphs)
      // enable multipage rendering
      buffer.attr(this, 'page', pages, 1)
    }
  }

  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere()
    }

    var positions = this.attributes.position.array
    var itemSize = this.attributes.position.itemSize
    if (!positions || !itemSize || positions.length < 2) {
      this.boundingSphere.radius = 0
      this.boundingSphere.center.set(0, 0, 0)
      return
    }
    maths.computeSphere(positions, this.boundingSphere)
    if (isNaN(this.boundingSphere.radius)) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): ' +
        'Computed radius is NaN. The ' +
        '"position" attribute is likely to have NaN values.')
    }
  }

  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3()
    }

    var bbox = this.boundingBox
    var positions = this.attributes.position.array
    var itemSize = this.attributes.position.itemSize
    if (!positions || !itemSize || positions.length < 2) {
      bbox.makeEmpty()
      return
    }
    maths.computeBox(positions, bbox)
  }
}