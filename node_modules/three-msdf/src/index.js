/**
@author Yannis Jonckheere
*/

import {
  Object3D,
  Mesh,
  RawShaderMaterial,
  Color,
  Vector2,
  Vector3
} from 'three'

import merge from 'lodash.merge'

import CreateGeometry from './utils/textGeometry'
import BMFontLoader from './utils/bmfontLoader'
import GetFOV from './utils/getWorldFieldOfView'

import vert from './shaders/vert.glsl'
import frag from './shaders/frag.glsl'

export default class TextMSDF extends Object3D {
  get layout() {
    return this.geometry.layout
  }

  get width() {
    return this.layout.width * this.scale.x
  }

  get heigth() {
    return this.layout.height * this.scale.x
  }

  get fontSizeRatio() {
    return this.options.font ? (this.options.fontSize / this.options.font.info.size) : 1
  }

  /**
   * @param  {} {options={}
   * @param  {} texture
   * @param  {} uniforms={}
   * @param  {} parameters={}
   * @param  {} shaders={}
   * @param  {} camera
   * @param  {} renderer}
   */
  constructor({ options = {}, texture, uniforms = {}, parameters = {}, shaders = {}, camera, renderer }) {
    super()

    this.createOptions(options)

    this.texture = texture

    this.uniforms = uniforms

    this.parameters = parameters

    this.camera = camera

    this.renderer = renderer

    this.shaders = {
      vert: shaders.vertex || vert,
      frag: shaders.fragment || frag
    }

    this.pixelConversion = 1

    this.origin = new Vector3(0, 0, 0)

    if (!this.camera) {
      throw new Error('Missing parameter - camera.')
    }

    if (!this.renderer) {
      throw new Error('Missing parameter - renderer.')
    }

    if (!this.options.font) {
      if (!this.options.fontInfos) {
        throw new Error('Missing parameter - fontInfos. Or load files before and use font and image parameters.')
      } else if (!this.options.fontImage) {
        throw new Error('Missing parameter - fontImage.')
      } else {
        this.loader = new BMFontLoader({
          attributes: {
            font: this.options.fontInfos,
            image: this.options.fontImage
          }
        })
        this.loader.load(asset => {
          this.options.font = asset.font
          this.options.flipY = asset.texture.flipY
          this.texture = asset.texture

          this.resetWidth()

          this.init()
        })
      }
    } else {
      this.init()
    }

  }

  /**
   * @param  {} options
   */
  createOptions(options) {
    if (!this.options) {
      this.options = {
        fontSize: 16,
        anchor: {
          x: 'left',
          y: 'top'
        }
      }
    }

    this.options = merge(
      {},
      this.options,
      options
    )

    if (options.width) {
      this.options.originalWidth = options.width
    }

    this.resetWidth()
  }

  init() {
    this.geometry = new CreateGeometry(this.options)

    this.parameters = merge(
      {
        transparent: true
      },
      this.parameters
    )

    this.uniforms = merge(
      {},
      {
        map: {
          value: this.texture
        },
        opacity: {
          value: this.options.opacity ? this.options.opacity : 1
        },
        color: {
          value: new Color(this.options.color ? this.options.color : '#fff')
        },
        size: {
          value: new Vector2(this.geometry.layout.width, this.geometry.layout.height)
        }
      },
      this.uniforms
    )


    this.material = new RawShaderMaterial({
      vertexShader: this.shaders.vert,
      fragmentShader: this.shaders.frag,
      uniforms: this.uniforms,
      ...this.parameters
    })

    this.mesh = new Mesh(this.geometry, this.material)

    this.resetPosition()

    this.resize()

    this.add(this.mesh)
  }

  resetPosition() {
    if (this.options.anchor.x === 'center') {
      this.mesh.position.x = -this.layout.width * 0.5
    } else if (this.options.anchor.x === 'right') {
      this.mesh.position.x = -this.layout.width
    } else {
      this.mesh.position.x = 0
    }

    if (this.options.anchor.y === 'center') {
      this.mesh.position.y = -this.layout.height * 0.5 - this.layout.descender
    } else if (this.options.anchor.y === 'bottom') {
      this.mesh.position.y = - this.layout.descender
    } else {
      this.mesh.position.y = -this.layout.height - this.layout.descender
    }
  }

  resetScale() {
    const s = this.pixelConversion * this.fontSizeRatio

    this.scale.set(s, s, s)
  }

  resetWidth() {
    this.options.width && (this.options.width = this.options.originalWidth / this.fontSizeRatio)
  }

  /**
   * Update font text or style
   * 
   * @param  {} options
   * @param  {} reset=true
   */
  update(options, reset = true) {
    this.createOptions(options)
    this.geometry.update(options)

    if (reset) {
      this.resetPosition()
      this.resize()
    }
  }

  resize() {
    this.WFV = GetFOV(this.camera, this.renderer, this.camera.position.origin.distanceTo(this.origin))

    this.pixelConversion = this.WFV.width / this.renderer.domElement.clientWidth

    this.resetScale()
  }
}